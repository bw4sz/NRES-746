install.packages("rmarkdown")
knitr::opts_chunk$set(echo = TRUE)
courseSchedule <- read.csv("CourseSchedule.csv")
courseSchedule
pryr
install.packages("pryr")
library(pryr)
detach("package:pryr", unload=TRUE)
library("pryr", lib.loc="~/R/win-library/3.2")
knitr::opts_chunk$set(echo = TRUE)
TRUEMIN <- 10      # minimum possible value for a hypothetical random variable
TRUEMAX <- 20      #  ... and the maximum
# define the samples to be drawn from this hypothetical distribution
N_IND_SAMPLES <- 1000   # number of random samples to draw
SAMPLESIZE <- 100       # size of each sample
lots <- 100000          # define a "practically infinite" large number
datafountain <- runif(lots,TRUEMIN,TRUEMAX) # everlasting font of pure unadulterated data
samplemean <- numeric(N_IND_SAMPLES)
for(i in 1:N_IND_SAMPLES){
sample <- sample(datafountain,SAMPLESIZE)
samplemean[i] <- mean(sample)
}
hist(datafountain)
hist(samplemean)
hist(datafountain)
hist(datafountain)
hist(samplemean)
hist(datafountain)
hist(datafountain,freq=F)
hist(datafountain,freq=F,ylim=c(0,1))
hist(samplemean,freq=F,add=T,col="red")
hist(datafountain,freq=F,ylim=c(0,1))
hist(samplemean,freq=F
)
hist(datafountain,freq=F,ylim=c(0,1))
hist(samplemean,freq=F,add=T,col="red")
TRUEMIN <- 10      # minimum possible value for a hypothetical random variable
TRUEMAX <- 20      #  ... and the maximum
# define the samples to be drawn from this hypothetical distribution
N_IND_SAMPLES <- 1000   # number of random samples to draw
SAMPLESIZE <- 10       # size of each sample
lots <- 100000          # define a "practically infinite" large number
datafountain <- runif(lots,TRUEMIN,TRUEMAX) # everlasting font of pure unadulterated data
samplemean <- numeric(N_IND_SAMPLES)
for(i in 1:N_IND_SAMPLES){
sample <- sample(datafountain,SAMPLESIZE)
samplemean[i] <- mean(sample)
}
hist(datafountain,freq=F,ylim=c(0,1))
hist(samplemean,freq=F,add=T,col="red")
knitr::opts_chunk$set(echo = TRUE)
GroupA = c(175, 168, 168, 190, 156, 181, 182, 175, 174, 179)
GroupB = c(185, 169, 173, 173, 188, 186, 175, 174, 179, 180)
cbind(GroupA,GroupB)
t.test(GroupA,GroupB, var.equal=TRUE, paired=FALSE)
lots <- 1000000  # large number approximating infinity in this example!
popMean_null <- mean(c(GroupA,GroupB))
popMean_null
data <- as.data.frame(cbind(GroupA,GroupB))
summary(data)
data <- data.frame(
GroupA = c(175, 168, 168, 190, 156, 181, 182, 175, 174, 179),
GroupB = c(185, 169, 173, 173, 188, 186, 175, 174, 179, 180)
)
summary(data)
install.packages("tidyr")
install.packages("dplyr")
install.packages("dplyr")
install.packages("Rcpp")
knitr::opts_chunk$set(echo = TRUE)
data <- data.frame(
GroupA = c(175, 168, 168, 190, 156, 181, 182, 175, 174, 179),
GroupB = c(185, 169, 173, 173, 188, 186, 175, 174, 179, 180)
)
summary(data)
?gather
install.packages("tidyr")
library(dplyr)
library(tidyr)
?gather
gather(data,"Group")
gather(data)
gather(data,"Group")
gather(data,"Group","Height")
data <- data.frame(
GroupA_height = c(175, 168, 168, 190, 156, 181, 182, 175, 174, 179),
GroupB_height = c(185, 169, 173, 173, 188, 186, 175, 174, 179, 180)
)
summary(data)
plot(gather(data,"Group"))
plot(Height~Group, data=gather(data,"Group","Height"))
data <- data.frame(
GroupA_height = c(175, 168, 168, 190, 156, 181, 182, 175, 174, 179),
GroupB_height = c(185, 169, 173, 173, 188, 186, 175, 174, 179, 180)
)
summary(data)
gather(data,"Group","Height")
gather(data,"Group","Height")
plot(Height~Group, data=gather(data,"Group","Height"))
plot(Height~Group, data=gather(data,"Group","Height"))
data <- data.frame(
GroupA = c(175, 168, 168, 190, 156, 181, 182, 175, 174, 179),
GroupB = c(185, 169, 173, 173, 188, 186, 175, 174, 179, 180)
)
summary(data)
sample.size <- length(data$GroupA)
summary(data)
sample.size <- length(data$GroupA)
reshape_data <- data.frame(
Group = rep(c("A","B"),each=sample.size),
Height = c(data$GroupA,data$GroupB)
)
reshape_data
reshape_data
plot(Height~Group, data=reshape_data)
lots <- 1000000  # large number approximating infinity in this example!
popMean_null <- mean(c(GroupA,GroupB))        # assume groups A and B come from a population with common mean
popMean_null <- mean(reshape_data$Height)        # assume groups A and B come from a population with common mean
popMean_null
popSD_null <- sd(reshape_data$Height)
popData_null <- rnorm(n=lots,mean=popMean_null,sd=popSD_null)
?sample
sample(popData_null,size=sample.size)
difference <- mean(sampleA)-mean(sampleB)
sampleA <- sample(popData_null,size=sample.size)
sampleB <- sample(popData_null,size=sample.size)
sampleA
difference <- mean(sampleA)-mean(sampleB)
reps <- 1000
null_difs <- numeric(reps)
for(i in 1:reps){
sampleA <- sample(popData_null,size=sample.size)
sampleB <- sample(popData_null,size=sample.size)
null_difs[i] <- mean(sampleA)-mean(sampleB)
}
hist(null_difs)
observed_dif <- mean(data$GroupA) - mean(data$GroupB)
observed_dif
?abline
hist(null_difs)
abline(v=observed_dif)
hist(null_difs)
abline(v=observed_dif)
hist(null_difs)
abline(v=observed_dif,col="green",lwd=3)
ordered_difs <- sort(null_difs)
ordered_difs <- sort(abs(null_difs))   # first order the distribution of null results in terms of absolute magnitude of difference
ordered_difs
length(which(ordered_difs>observed_dif))
higher_anomaly <- length(which(ordered_difs>=observed_dif))
observed_dif
higher_anomaly <- length(which(ordered_difs>=abs(observed_dif)))
higher_anomaly
p_value <- higher_anomaly/reps   # probability of getting a value with anomaly as or more extreme than observed, given null hypothesis is true...
p_value
t.test(GroupA,GroupB, data=data, var.equal=TRUE, paired=FALSE)
data <- data.frame(
GroupA = c(175, 168, 168, 190, 156, 181, 182, 175, 174, 179),
GroupB = c(185, 169, 173, 173, 188, 186, 175, 174, 179, 180)
)
t.test(GroupA,GroupB, data=data, var.equal=TRUE, paired=FALSE)
?t.test
data
t.test(GroupA,GroupB, data=data, var.equal=TRUE, paired=FALSE)
t.test(data$GroupA,data$GroupB, var.equal=TRUE, paired=FALSE)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
help(trees)
head(trees)
head(trees)
plot(trees$Volume~trees$Height, main = 'Black Cherry Tree Volume Relationship', xlab = 'Height', ylab = 'Volume', pch = 16, col ='blue')
plot(trees$Volume~trees$Girth, main = 'Black Cherry Tree Volume Relationship', xlab = 'Girth', ylab = 'Volume', pch = 16, col ='red')
plot(trees$Volume~trees$Height, main = 'Black Cherry Tree Volume Relationship', xlab = 'Height', ylab = 'Volume', pch = 16, col ='blue')
response = c(1:10)
predictor = rnorm(10)
model <- lm(response~predictor)
mode
model
summary(model)
summary(model)$Coefficients
summary(model)$r.square
Rsquared(trees$Volume,trees$Girth)
Rsquared <- function(response, predictor){
model <- lm(response~predictor)
rsq <- summary(model)$r.square
return(rsq)
}
Rsquared(trees$Volume,trees$Girth)
Rsquared(trees$Volume,trees$Girth)
Rsquared(trees$Volume,trees$Height)
trees
df=trees
responsevar="Volume"
data[,responsevar]
response <- df[,responsevar]
response
names <- names(df)
names
names(df)[-responsevar]
responsevar
[-c(responsevar)]
names(df)[-c(responsevar)]
rsq <- numeric(length(names))
rsq
names(rsq) <- names(df)
rsq <- rsq[-responsevar]
rsq
responsevar
rsq <- rsq[names(rsq!=responsevar)]
rsq
names(rsq!=responsevar)
names(rsq)!=responsevar
rsq <- rsq[names(rsq)!=responsevar]
rsq
names(rsq)
df[,i]
names(rsq)
i="Girth"
predictor <- df[,i]
model <- lm(response~predictor)
rsq <- summary(model)$r.square
response <- df[,responsevar]
names <- names(df)
rsq <- numeric(length(names))
names(rsq) <- names(df)
rsq <- rsq[names(rsq)!=responsevar]
predictor <- df[,i]
model <- lm(response~predictor)
Rsquared <- function(df,responsevar,interactions=FALSE){    # interactions not yet implemented
response <- df[,responsevar]
names <- names(df)
rsq <- numeric(length(names))
names(rsq) <- names(df)
rsq <- rsq[names(rsq)!=responsevar]
for(i in names(rsq)){         # loop through predictors
predictor <- df[,i]
model <- lm(response~predictor)
rsq[i] <- summary(model)$r.square
}
return(rsq)
}
Rsquared(trees,"Volume")
indices <- c(1:nrow(df))
indices
boot_rows <- sample(indices,size=nrow(df),replace=T)
boot_rows
n=10
statfunc=Rsquared
statfunc
df
df
statfunc
n_samples=10
n_stats=2
indices <- c(1:nrow(df))
output <- matrix(NA,nrow=n_samples,ncol=n_stats)
newdf <- df[boot_rows,]
newdf
newdf
Rsquared <- function(df,responsevar="Volume"){    # interactions not yet implemented
response <- df[,responsevar]
names <- names(df)
rsq <- numeric(length(names))
names(rsq) <- names(df)
rsq <- rsq[names(rsq)!=responsevar]
for(i in names(rsq)){         # loop through predictors
predictor <- df[,i]
model <- lm(response~predictor)
rsq[i] <- summary(model)$r.square
}
return(rsq)
}
Rsquared(trees,"Volume")
output <- matrix(NA,nrow=n_samples,ncol=n_stats)
i=1
boot_rows <- sample(indices,size=nrow(df),replace=T)
newdf <- df[boot_rows,]
output[i,] <- statfunc(newdf,params)
output[i,] <- statfunc(newdf,params)
output[i,] <- statfunc(newdf)
Rsquared <- function(df,responsevar="Volume"){    # interactions not yet implemented
response <- df[,responsevar]
names <- names(df)
rsq <- numeric(length(names))
names(rsq) <- names(df)
rsq <- rsq[names(rsq)!=responsevar]
for(i in names(rsq)){         # loop through predictors
predictor <- df[,i]
model <- lm(response~predictor)
rsq[i] <- summary(model)$r.square
}
return(rsq)
}
statfunc=Rsquared
boot_rows <- sample(indices,size=nrow(df),replace=T)
newdf <- df[boot_rows,]
output[i,] <- statfunc(newdf)
boot_sample <- function(df,statfunc,n_samples,n_stats){
indices <- c(1:nrow(df))
output <- matrix(NA,nrow=n_samples,ncol=n_stats)
for(i in 1:n_samples){
boot_rows <- sample(indices,size=nrow(df),replace=T)
newdf <- df[boot_rows,]
output[i,] <- statfunc(newdf)
}
return(output)
}
boot <- boot_sample(trees,Rsquared,10,2)
colnames(boot) <- names(stat)
stat <- Rsquared(trees,"Volume")
stat
boot <- boot_sample(trees,Rsquared,10,2)
colnames(boot) <- names(stat)
boot
stat
boot <- boot_sample(trees,Rsquared,1000,length(stat))   # 1000 bootstrap samples
boot
quantile(boot,c(0.025,0.975))
apply(boot,2,function(t)  quantile(t,c(0.025,0.975)))
confint <- apply(boot,2,function(t)  quantile(t,c(0.025,0.5,0.975)))
names(confint) <- names(stat)
t(confint)
confint <- apply(boot,2,function(t)  quantile(t,c(0.025,0.5,0.975)))
names(confint) <- names(stat)
confint
confint <- apply(boot,2,function(t)  quantile(t,c(0.025,0.5,0.975)))
confint
colnames(confint) <- names(stat)
confint
t(confint)
knit_with_parameters('E:/GIT/NRES-746/index.Rmd', encoding = 'UTF-8')
knit_with_parameters('E:/GIT/NRES-746/index.Rmd', encoding = 'UTF-8')
library("knitr")
knit2html("index.Rmd")
?render_markdown
install.packages("devtools")
library(devtools)
devtools::install_github("rstudio/rmarkdown")
library(rmarkdown)
site_libs
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
?trees
help("datasets")
library(help = "datasets")
head(air.cleaned)
air.cleaned <- na.omit(airquality) # you can call what’s created on the left-hand side anything you want!
head(air.cleaned)
model1 <- lm(Ozone~Solar.R+Wind+Temp)
model1 <- lm(Ozone~Solar.R+Wind+Temp,data=air.cleaned)
par(mfrow=c(2,2))
plot.lm
?plot.lm
par(mfrow=c(2,2))
plot.lm(model1, which=c(1:4))
library(stats)
plot.lm(model1, which=c(1:4))
stats:::plot.lm(model1, which=c(1:4))
stats:::plot.lm(model1, which=c(1:4))
stats::plot.lm(model1, which=c(1:4))
plot(model1)
plot(model1, which=c(1:4))   # in some cases, need to make sure
stats:::plot.lm(model1, which=c(1:4))   # in some cases, need to make sure
plot(predict(ozone1.lm) ~ Ozone); ab
hist(residuals(model1), breaks=10)
plot(predict(model1) ~ air.cleaned$Ozone); abline(0,1)
stats:::plot.lm(model1, which=c(1))   # in some cases, need to make sure the package is explicitly references!
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
TRUEMIN <- 10
TRUEMAX <- 20
N_IND_SAMPLES <- 1000
SAMPLESIZE <- 10
lots <- 100000
datafountain <- runif(lots,TRUEMIN,TRUEMAX)
samplemean <- numeric(N_IND_SAMPLES)
for(i in 1:N_IND_SAMPLES){
sample <- sample(datafountain,SAMPLESIZE)
samplemean[i] <- mean(sample)
}
hist(datafountain,freq=F,ylim=c(0,1))
hist(samplemean,freq=F,add=T,col="red")
air.cleaned <- na.omit(airquality) # you can call what’s created on the left-hand side anything you want!
stats:::plot.lm(model1, which=c(1:4))   # in some cases, need to make sure the package is explicitly referenced!
?plot.lm
?rstandard
?rstudent
?plot.lm
?symbols
air.cleaned
symbols(Temp, Solar.R, Ozone/100, ylab="Solar Radiation", xlab="Temperature", main="Interaction Plot", inches=FALSE,data=air.cleaned)
with(air.cleaned,
symbols(Temp, Solar.R, Ozone/100, ylab="Solar Radiation", xlab="Temperature", main="Interaction Plot", inches=FALSE)
)
with(air.cleaned,
symbols(Temp, Solar.R, circles=Ozone/100, ylab="Solar Radiation", xlab="Temperature", main="Interaction Plot", inches=FALSE)
)
?coplot
attach(air.cleaned)
coplot(Ozone~Solar|Temp)
coplot(Ozone~Solar.R|Temp)
coplot(Ozone~Temp|Solar.R)
?coplot
ll.dm <- lat ~ long | depth * mag
coplot(ll.dm, data = quakes)
coplot(lat ~ long | depth, data = quakes)
coplot(Ozone~Temp|Solar.R)
coplot(Ozone~Temp|Solar.R,rows=1)
with(air.cleaned, # with"" is a way to temporarily "attach" a data set to the workspace
{symbols(Temp, Solar.R, circles=Ozone/100, ylab="Solar Radiation", xlab="Temperature", main="Interaction Plot", inches=FALSE);
coplot(Ozone~Temp|Solar.R,rows=1)}
)
with(air.cleaned, # with"" is a way to temporarily "attach" a data set to the workspace
{symbols(Temp, Solar.R, circles=Ozone/100, ylab="Solar Radiation", xlab="Temperature", main="Interaction Plot", inches=FALSE);
coplot(Ozone~Temp|Solar.R,rows=1)}
)
with(air.cleaned, # with"" is a way to temporarily "attach" a data set to the workspace
symbols(Temp, Solar.R, circles=Ozone/100, ylab="Solar Radiation", xlab="Temperature", main="Interaction Plot", inches=FALSE)
)
with(air.cleaned, # with"" is a way to temporarily "attach" a data set to the workspace
symbols(Temp, Solar.R, circles=Ozone/100, ylab="Solar Radiation", xlab="Temperature", main="Interaction Plot", inches=FALSE)
)
formula <- Ozone ~ Wind + Solar.R * Temp    # you can name formulas...
formula2 <- Ozone ~ Wind + Solar.R * Temp    # you can name formulas...
formula2 <- Ozone ~ Wind + Solar.R * Temp    # you can name formulas...
model2 <- lm(formula,data=air.cleaned)
model2 <- lm(formula,data=air.cleaned)
anova(model1, model2.lm, test="F")
anova(model1, model2, test="F")
anova(model1, model2, test="LRT")
AIC(model1)
AIC(model2)
anova(model1, model2, test="F")
NobleFir.df <- read.csv("TreeData.csv")
cor(NobleFir.df[,c(2,4,7:9)])
boxplot(NobleFir.df$ABPR~NobleFir.df$SlopePos)
boxplot(NobleFir.df$ABPR~NobleFir.df$Northeastness)   # for example
boxplot(NobleFir.df$ABPR,NobleFir.df$Northeastness)   # for example
plot(NobleFir.df$ABPR~NobleFir.df$Northeastness)   # for example
boxplot(NobleFir.df$ABPR,NobleFir.df$Northeastness)   # for example
NobleFir.df$ABPR
?boxplot
boxplot(NobleFir.df$Northeastness~NobleFir.df$ABPR)   # for example
boxplot(NobleFir.df$Northeastness~NobleFir.df$ABPR, xlab="Presence of Noble Fir", ylab="Northeastness")   # for example
Biomass_std.lm <- lm(scale(Biomass) ~ scale(elev) + scale(Northeastness) + scale(Slope) + SlopePos + scale(StandAge))
with(NobleFir.df,
Biomass_std.lm <- lm(scale(Biomass) ~ scale(elev) + scale(Northeastness) + scale(Slope) + SlopePos + scale(StandAge))
)
with(NobleFir.df,
Biomass_std.lm <- lm(scale(Biomass) ~ scale(elev) + scale(Northeastness) + scale(Slope) + SlopePos + scale(StandAge))
)
Biomass_std.lm
Biomass_std.lm <- with(NobleFir.df,
lm(scale(Biomass) ~ scale(elev) + scale(Northeastness) + scale(Slope) + SlopePos + scale(StandAge))
)
Biomass_std.lm
symbols(x,y,circles=abs(residuals(Biomass_std.lm)), inches=0.3, ylab="Northing", xlab="Easting", main="Errors from Biomass Regression Model")
with(NobleFir.df,
symbols(x,y,circles=abs(residuals(Biomass_std.lm)), inches=0.3, ylab="Northing", xlab="Easting", main="Errors from Biomass Regression Model")
)
boxplot(NobleFir.df$Northeastness~NobleFir.df$ABPR, xlab="Presence of Noble Fir", ylab="Northeastness")   # for example
cor(NobleFir.df[,c(2,4,7:9)])
NobleFir.df <- read.csv("TreeData.csv")
model2 <- lm(formula,data=air.cleaned)
formula2 <- Ozone ~ Wind + Solar.R * Temp    # you can name formulas...
with(air.cleaned, # with"" is a way to temporarily "attach" a data set to the workspace
symbols(Temp, Solar.R, circles=Ozone/100, ylab="Solar Radiation", xlab="Temperature", main="Interaction Plot", inches=FALSE)
)
# alternatively...
with(air.cleaned,
coplot(Ozone~Temp|Solar.R,rows=1)
)
Biomass_std.lm <- with(NobleFir.df,
lm(scale(Biomass) ~ scale(elev) + scale(Northeastness) + scale(Slope) + SlopePos + scale(StandAge))
)
Biomass_std.lm <- with(NobleFir.df,
lm(scale(Biomass) ~ scale(elev) + scale(Northeastness) + scale(Slope) + SlopePos + scale(StandAge))
)
Biomass_std.lm <- with(NobleFir.df,
lm(scale(Biomass) ~ scale(elev) + scale(Northeastness) + scale(Slope) + SlopePos + scale(StandAge))
)
Biomass_std.lm
boxplot(NobleFir.df$Northeastness~NobleFir.df$ABPR, xlab="Presence of Noble Fir", ylab="Northeastness")   # for example
cor(NobleFir.df[,c(2,4,7:9)])
NobleFir.df <- read.csv("TreeData.csv")
formula2 <- Ozone ~ Wind + Solar.R * Temp    # you can name formulas...
model2 <- lm(formula,data=air.cleaned)
detach()
detach()
detach()
detach()
detach()
detach()
detach()
detach()
detach()
detach()
formula2 <- as.formula("Ozone ~ Wind + Solar.R * Temp")    # you can name formulas...
formula2 <- "Ozone ~ Wind + Solar.R * Temp"
library(rmarkdown)
library("evaluate", lib.loc="~/R/win-library/3.3")
library("yaml", lib.loc="~/R/win-library/3.3")
library("htmltools", lib.loc="~/R/win-library/3.3")
library("knitr", lib.loc="~/R/win-library/3.3")
library("lazyeval", lib.loc="~/R/win-library/3.3")
library("dplyr", lib.loc="~/R/win-library/3.3")
library("Rcpp", lib.loc="~/R/win-library/3.3")
library("markdown", lib.loc="~/R/win-library/3.3")
detach("package:markdown", unload=TRUE)
library("markdown", lib.loc="~/R/win-library/3.3")
library("magrittr", lib.loc="~/R/win-library/3.3")
library("stats", lib.loc="C:/Program Files/R/R-3.3.1/library")
